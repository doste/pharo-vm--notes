### Bytecode generation for constants

If we have a method like this:
```
    increment: a
        ^ a + 1
```

The generated bytecode will look something like this:
```
    push arg0
    push 1
    send: +
    returnTop
```

The `push 1` instruction get translated to another instruction: `pushConstantOne`

```
pushConstantOne
    self fetchNextBytecode 
    self  push: constOne
```

The actual 1 that is pushed comes from an instance variable. Some small constants are defined like so. 

But what happens if we have a method like this:
```
    foo: a 
        ^ 150 + a
```
The generated bytecode will have to push somewhere the number 150, but there is no `constOneHundredFifty`! 

From a bytecode design perspective we have 3 options:

1) Break down the 150 in a succession of pushes and additions and multiplications, something like this:
```
push 1
push 1
send: *
push 1
push 1
send: *
send: +
...
```
We would have to do this until we have a 150 in the stack. This works but of course it's not very appealing.

2) Have the 150 on the bytecode itself. This means having the actual number in the bytecode stream.
 This would imply having bigger bytecodes. Which maybe it's not something we would like to end up with.

3) Have the 150 appear somewhere accessible. This place is called a `Table of Literals`. 
 This is where all the literals used in the method will appear. It's a table that is part of the `CompiledMethod` that results from compiling a method.
 Such an object will have two main sections: the bytecode itself and the literals.

 This third option is the one used in the Pharo VM.


So, for our example, the 150 will end up being in the table of literals, and then when the bytecode wants to access it, it will reference it by its position in the table.

The resulting `CompiledMethod` will look like this:

<img width="267" alt="Screenshot 2024-04-30 at 11 16 14â€¯AM" src="https://github.com/doste/pharo-vm--notes/assets/12955548/518d7fe7-853f-469f-bec9-3357424ef660">


#### Small note about bytecodes:
    There are bytecodes of 1, 2 and 3 bytes.

    Suppose that our bytecode stream looks like this:
    
    ```  ... 201 17 38 ... ```

    And that the 201 bytecode is a 2 byte bytecode. So, the numbers 201 17 corresponds to a single bytecode.

    When the interpreter is executing it, it will run the code corresponding to the bytecode 201, but this code has to make sure to 'consume' the next bytecode, the 17 in our example.
    After consuming it, it has to advance too. This way the next instruction to execute will be the 38.
