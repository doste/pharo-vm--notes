## Bytecode generation for constants

This section explains how constants are represented in bytecode. Let's consider for example the following code:

```
    increment: a
        ^ a + 1
```

When we compile a method like that what we get is a `CompiledMethod` object.
 This kind of object has mainly two things: a table of literals and the bytecodes.

The bytecodes are basically the instructions for the interpreter.

And the table of literals consist of a table where constant values are put. 
For example, if inside our method there is a string defined, then that string will be put as a literal.
The same applies for arrays and other objects.

Integer constants are also set as literals.

The generated bytecodes from the method `increment` will look something like this:
```
    push arg0
    push 1
    send: +
    returnTop
```

The `push 1` instruction get translated to another instruction: `pushConstantOne`

```
pushConstantOne
    self fetchNextBytecode 
    self  push: constOne
```

The actual 1 that is pushed comes from an instance variable. Some small constants are defined like so. 

This is an optimization.

Let's see how it works:

What happens if we have a method like this:
```
    foo: a 
        ^ 150 + a
```
The generated bytecode will have to push somewhere the number 150, but there is no `constOneHundredFifty`! 


That value 150 will have to be in the table of literals.

Of course this applies to any constant number that our code uses.

*But* there are a few of these constants that are used a lot.

This is where the mentioned optimization enters:

Instead of using an entry in the table, we use the `pushConstantOne` method. 

So this is a *memory* optimization, by having the constant `1` as a special method and as such occupying one less entry in the table.

There are a couple of other cases of this optimization, even for other kinds of constants, for example for `nil`, `true`, `false`.
[To see them all check the methods in the class `StackInterpreter`]

So, for our example, the 150 will end up being in the table of literals, and then when the bytecode wants to access it, it will reference it by its position in the table.

The resulting `CompiledMethod` from the `foo:` method will look like this:

```
        _____________________
        | 1: 150            |
        | 2: ...            |
        | ...               |
        |                   |
        |___________________|
        |  pushLiteral: 1   |
        |  pushTemp: 0      |
        |  send: +          |
        |  returnTop        |
        |___________________|
```

### From a bytecode design perspective, what are some alternatives for dealing with constants?

#### 1) Assuming we have the optimized `pushConstantOne` we can think of a way to use it to obtain the desired constant from it by performing differents operations.

 For our example, we would break down the 150 in a succession of `push:1` and additions and multiplications, something like this:
```
push 1
push 1
send: *
push 1
push 1
send: *
send: +
...
```
We would have to do this until we have a 150 in the stack.
With this approach we have a tradeoff: We use less memory (we have one entry less in the table of literals) but have more instructions to execute.



#### 2) Have the 150 on the bytecode itself. This means having the actual number in the bytecode stream.
 This would imply having bigger bytecodes. Which maybe it's not something we would like to end up with.


### Small note about bytecodes:
    There are bytecodes of 1, 2 and 3 bytes.

    Suppose that our bytecode stream looks like this:
    
    ```  ... 201 17 38 ... ```

    And that the 201 bytecode is a 2 byte bytecode. So, the numbers 201 17 corresponds to a single bytecode.

    When the interpreter is executing it, it will run the code corresponding to the bytecode 201, but this code has to make sure to 'consume' the next bytecode, the 17 in our example.
    After consuming it, it has to advance too. This way the next instruction to execute will be the 38.
